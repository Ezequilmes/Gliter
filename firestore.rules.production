// Firestore Security Rules for Production
// These rules are more restrictive and secure for production use

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for authentication and authorization
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             request.auth.token.admin == true;
    }
    
    function isModerator() {
      return isAuthenticated() && 
             (request.auth.token.admin == true || request.auth.token.moderator == true);
    }
    
    function isValidUser() {
      return isAuthenticated() && 
             request.auth.token.email_verified == true;
    }
    
    // User profiles - users can only read/write their own profile
    match /users/{userId} {
      allow read: if isAuthenticated() && 
                     (isOwner(userId) || isAdmin());
      allow write: if isOwner(userId) && 
                      isValidUser() &&
                      validateUserData();
      allow create: if isOwner(userId) && 
                       isValidUser() &&
                       validateUserData();
      allow delete: if isOwner(userId) || isAdmin();
      
      function validateUserData() {
        let data = request.resource.data;
        return data.keys().hasAll(['email', 'createdAt']) &&
               data.email == request.auth.token.email &&
               data.createdAt is timestamp;
      }
    }
    
    // Public user profiles (limited data for discovery)
    match /publicProfiles/{userId} {
      allow read: if isAuthenticated();
      allow write: if isOwner(userId) && 
                      isValidUser() &&
                      validatePublicProfileData();
      allow create: if isOwner(userId) && 
                       isValidUser() &&
                       validatePublicProfileData();
      allow delete: if isOwner(userId) || isAdmin();
      
      function validatePublicProfileData() {
        let data = request.resource.data;
        let required = ['displayName', 'age', 'lastActive'];
        let allowed = ['displayName', 'age', 'lastActive', 'photoURL', 'gender', 'bio', 'interests', 'location'];
        return data.keys().hasAll(required) &&
               data.keys().hasOnly(allowed) &&
               data.displayName is string &&
               data.displayName.size() >= 1 && data.displayName.size() <= 50 &&
               data.age is int && data.age >= 18 && data.age <= 100 &&
               data.lastActive is timestamp &&
               (!('photoURL' in data) || (data.photoURL is string && data.photoURL.size() <= 500)) &&
               (!('gender' in data) || (data.gender is string && data.gender.size() <= 30)) &&
               (!('bio' in data) || (data.bio is string && data.bio.size() <= 280)) &&
               (!('interests' in data) || (data.interests is list && data.interests.size() <= 20)) &&
               (!('location' in data) || (data.location is map));
      }
    }
    
    // Chat conversations
    match /conversations/{conversationId} {
      allow read: if isAuthenticated() && 
                     (request.auth.uid in resource.data.participants || isAdmin());
      allow write: if isAuthenticated() && 
                      isValidUser() &&
                      request.auth.uid in resource.data.participants &&
                      validateConversationData();
      allow create: if isAuthenticated() && 
                       isValidUser() &&
                       request.auth.uid in request.resource.data.participants &&
                       validateConversationData();
      allow delete: if isAdmin();
      
      function validateConversationData() {
        let data = request.resource.data;
        return data.keys().hasAll(['participants', 'createdAt', 'lastMessage']) &&
               data.participants is list &&
               data.participants.size() == 2 &&
               data.createdAt is timestamp;
      }
      
      // Messages within conversations
      match /messages/{messageId} {
        allow read: if isAuthenticated() && 
                       (request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants || isAdmin());
        allow write: if isAuthenticated() && 
                        isValidUser() &&
                        request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                        validateMessageData();
        allow create: if isAuthenticated() && 
                         isValidUser() &&
                         request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                         validateMessageData();
        allow delete: if isOwner(resource.data.senderId) || isAdmin();
        
        function validateMessageData() {
          let data = request.resource.data;
          return data.keys().hasAll(['senderId', 'content', 'timestamp', 'type']) &&
                 data.senderId == request.auth.uid &&
                 data.timestamp is timestamp &&
                 data.type in ['text', 'image', 'location'] &&
                 data.content is string &&
                 data.content.size() <= 1000;
        }
      }
    }
    
    // User interactions (likes, blocks, reports)
    match /interactions/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow write: if isOwner(userId) && isValidUser();
      allow create: if isOwner(userId) && isValidUser();
      allow delete: if isOwner(userId) || isAdmin();
      
      match /likes/{targetUserId} {
        allow read: if isOwner(userId) || isAdmin();
        allow write: if isOwner(userId) && isValidUser();
        allow create: if isOwner(userId) && isValidUser();
        allow delete: if isOwner(userId) || isAdmin();
      }
      
      match /blocks/{targetUserId} {
        allow read: if isOwner(userId) || isAdmin();
        allow write: if isOwner(userId) && isValidUser();
        allow create: if isOwner(userId) && isValidUser();
        allow delete: if isOwner(userId) || isAdmin();
      }
    }
    
    // Reports (for moderation)
    match /reports/{reportId} {
      allow read: if isModerator();
      allow write: if isAuthenticated() && isValidUser();
      allow create: if isAuthenticated() && isValidUser() && validateReportData();
      allow update: if isModerator();
      allow delete: if isAdmin();
      
      function validateReportData() {
        let data = request.resource.data;
        return data.keys().hasAll(['reporterId', 'reportedUserId', 'reason', 'timestamp']) &&
               data.reporterId == request.auth.uid &&
               data.timestamp is timestamp &&
               data.reason in ['inappropriate_content', 'harassment', 'spam', 'fake_profile', 'other'];
      }
    }
    
    // Premium subscriptions and payments
    match /subscriptions/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow write: if isAdmin(); // Only admin/system can modify subscriptions
      allow create: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Payment transactions
    match /transactions/{transactionId} {
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow write: if isAdmin(); // Only admin/system can modify transactions
      allow create: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // System logs (admin only)
    match /logs/{logId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
      allow create: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Analytics data (admin only)
    match /analytics/{document=**} {
      allow read: if isAdmin();
      allow write: if isAdmin();
      allow create: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

// Storage Security Rules
// Note: These should be placed in storage.rules file
/*
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // User profile images
    match /users/{userId}/profile/{imageId} {
      allow read: if true; // Public read for profile images
      allow write: if request.auth != null && 
                      request.auth.uid == userId &&
                      request.resource.size < 5 * 1024 * 1024 && // 5MB limit
                      request.resource.contentType.matches('image/.*');
      allow delete: if request.auth != null && 
                       (request.auth.uid == userId || 
                        request.auth.token.admin == true);
    }
    
    // Chat images
    match /chats/{conversationId}/{imageId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && 
                      request.resource.size < 10 * 1024 * 1024 && // 10MB limit
                      request.resource.contentType.matches('image/.*');
      allow delete: if request.auth != null && 
                       request.auth.token.admin == true;
    }
    
    // Deny all other access
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
*/